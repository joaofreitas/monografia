\chapter{Fundamentos básicos}

Este capítulo apresenta os principais definições e conceitos necessários para o entendimento deste trabalho. Dividido em 4 seções, a primeira delas apresenta a teoria a respeito de IE. A Seção~\ref{section:sma} aborda os conceitos de SMA necessários ao entendimento deste trabalho. A Seção~\ref{section:mase} apresenta a teoria acerca da metodologia MASE, a decisão pela sua escolha e as fases de desenvolvimento. A Seção~\ref{section:ferramentas} reúne um estudo de ferramentas e tecnologias relacionadas a este trabalho. Por fim, a Seção~\ref{section:trabcorrelatos} aborda alguns trabalhos correlatos.

\section{Informática na Educação}
A IE constitui-se um importante ramo de estudo. O uso do computador como meio de educação tornou-se essencial atualmente. Popularizando meios inacessíveis em um passado recente, a aquisição de conhecimento foi simplificada e reduziu-se a um computador com conexão com a internet para o acesso a diversos tipos de conhecimento.
 
O computador passa então a ser uma forma de ensino, ocasionando na descentralização da figura do professor neste processo e, segundo [18], promove o desenvolvimento cognitivo por meio de uma interação maior entre o aluno e o objeto de conhecimento.
 
Com o crescimento da internet, surgem ambientes específicos para aplicações interativas que auxiliam o estudante. Estes ambientes, chamados de Ambientes Virtuais de Aprendizagem (AVA), surgiram na década de 90 com os cursos à distância e mais tarde com ferramentas interativas e em tempo real [28]. Da necessidade em organizar as informações geradas pelos AVA, surgiram os Sistemas Gerenciadores de Conteúdo e Aprendizagem (LCMS - Learning and Content Managment System).
 
A interação entre as ferramentas tornou-se cada vez maior e tornou-se cada vez mais necessário o ensino personalizado ao estudante. A personalização está relacionada com a forma específica que cada estudante tem ao lidar com informações, a melhor forma de aprender e as suas habilidades. Entre outras palavras, os Sistemas começaram a interagir mais com os alunos a fim de determinar a forma como os alunos percebem e processam as informações.

\subsection{Estilo de Aprendizagem}
O estilo de aprendizagem é a forma mais eficiente em que o estudante absorve conhecimento ao receber e processar uma informação. Um modelo de estilo de aprendizagem visa classificar um estudante de acordo com uma escala que, organiza as formas as quais são possíveis receber e processar o conhecimento~\cite{felder1988learning}. Estilos de aprendizagem não classificam em uma escala melhor ou pior do que outro estilo de aprendizagem, apenas categoriza o aluno de acordo com a forma de aprender.

O estilo de aprendizagem pode orientar melhor um docente a estimular um aluno durante o processo de desenvolvimento de suas habilidades, alterando o ambiente para o aluno de acordo com o estilo de forma a individualizar o processo didático do ensino. Existem diversos modelos de estilos de aprendizagem propostos na literatura, no entando será apresentado neste trabalho as teorias mais importantes dos modelos de estudantes.

\subsubsection{Modelo de~\emph{Kolb}}

A perspectiva da teoria experimental do aprendizado proposta em~~\emph{Kolb}~\cite{kolb84} enfatiza o fato da experiência no processo de aprendizagem. Kolb inicialmente baseia-se em um ciclo de aprendizado de quatro estágios: Experiência concreta, observação reflexiva, conceituação abstrata e experimentação ativa. Basicamente o ciclo funciona de forma à iniciar nas experiências concretas para prover fundamentos para o ciclo da observação reflexiva. A partir de observações e reflexões, novos conceitos abstratos são formados. Esses conceitos podem implicar em ações que podem ser colocadas em prática, criando assim novas experiências.

\emph{Kolb} propôs quatro estilos de aprendizagem: Divergente, assimilador, convergente e acomodador. Estes estilos estão permeados nos ciclos de aprendizagem definidos. A Tabela~\ref{lista_estilos_aprendizagem} exibe os estilos de aprendizagem propostos por~\emph{Kolb} combinados com o ciclo de aprendizado e a separação em quatro categorias.

\begin{table}
	\caption{Estilos de Aprendizagem definidos por Kolb}
	\begin{tabular}{|p{4cm} | p{3cm} | p{7cm} |}
		\hline
		\textbf{Estilo de Aprendizagem}	& \textbf{Ciclos} & \textbf{Descrição}	\\
		\hline
		Divergente	& Experiência Concreta, Observação Reflexiva & Pessoas que utilizam a imaginação com mais facilidade para resolver problemas. São capazes de olhar um problema por diferentes perspectivas. Possuem maior interesse cultural e prazer ao adquirir informações. 	\\
		\hline
		Assimilador	& Conceituação Abstrata, Observação Reflexiva & Possuem uma aproximação maior de raciocínio lógico, onde há ênfase em idéias e conceitos. São menos focados em pessoas e mais focados em conceitos abstratos. Valorizam mais as explicações detalhadas do que uma oportunidade prática. 	\\
		\hline
		Convergente	& Conceituação Abstrata, Experimentação Ativa & Possuem inclinação maior á situações práticas, onde utilizarão o seu conhecimento para resolver um problema de forma experimental.	\\
		\hline
		Acomodador	& Experiência Concreta, Experimentação Ativa & Usam-se de outras pessoas para suas análises, confiando em experiências de terceiros para tirar suas próprias conclusões.	\\
		\hline
	\end{tabular}
	\label{lista_estilos_aprendizagem}
\end{table}

\subsubsection{Modelo de~\emph{Felder}}
O modelo de Felder~\cite{felder1988learning} divide os seguintes estilos de aprendizagem:
\begin{itemize}
	\item Sensorial/Intuitivo.
	\item Visual/Verbal.
	\item Activo/Reflexivo.
	\item Sequêncial/Global.
\end{itemize}

O estilo sensorial categoriza alunos que favorecem o aprendizado por meio dos seus sentidos. Com tendências à abordagem prática no processo da aprendizagem, costumam lidar melhor com fatos e observações. Dessa forma, algumas disciplinas que focam em conceitos abstratos, teorias, fórmulas (como física e química) tendem a ser mais complicadas para estes alunos.

Alunos do estilo intuitivo favorecem informações que florecem em seu raciocínio interno, como a memória, situações imaginárias e por meio de reflexões. Eles normalmente gostam variar o tipo de trabalho, não se importando com a sua complexidade.

A categoria Visual agrupa alunos com mais eficiência em aprender com imagens, diferentemente dos alunos da Verbal categoria que são eficientes em materiais verbais, palavras escritas e discursos.

Estudantes do estilo Ativo tendem a aprender de forma a realizar tentativas, expressar suas idéias, realizar experimentações. Geralmente, conseguem trabalhar muito bem em grupos devido ao favorecimento da prática de exemplos. Em oposição, os estudantes reflexivos preferem um raciocínio mais internalizado e pensam bastante a respeito antes de tentar algo. Geralmente, preferem trabalhar sozinhos ou em pares.

O estilo Sequêncial reúne estudantes que entendem informações por meio de ``fragmentos de conhecimento conexos'', ou seja, partes de entendimento a respeito de um domínio que, juntos, comporiam uma imagem completa do conhecimento. Podem ser capazes de resolver problemas com um entendimento incompleto acerca de algum domínio. Todavia por não possuirem o entendimento completo, carecem de conseguir correlacionar as informações com outras áreas.

Por fim, o estilo Global possui alunos que detém domínio de grandes áreas de conhecimento, estes porém de forma desconexa. Em geral, ou detém todo o conhecimento a respeito de algo, ou não sabem nada. O processamento aparentemente é lento, mas depois do domínio total, conseguem fazer muito mais conexões com áreas correlatas do que alunos com o estilo de aprendizagem Sequêncial.

\subsubsection{Modelo de~\emph{Honey} e~\emph{Mumford}}
O modelo de Honey e Mumford faz uma alteração no ciclo de aprendizagem de Kolb e também define novos estilos de aprendizagem~\cite{muhlbeier12}:
\begin{itemize}
	\item Ativo: Pessoas que garantem o seu aprendizado na prática.
	\item Pragmático: Pessoas que precisam identificar como aplicar no mundo real a teoria estudada. Possuem inclinação à experimentações e abordagens práticas.
	\item Reflexivo: Aprendem durante a observação e refletindo sobre determinada ação, sem necessariamente praticá-la. Visualizam a ação de diversas perspectivas para fomentar o seu conhecimento.
	\item Teórico: Primam o entendimento da teoria por trás das ações. O aprendizado de novas informações ocorre por modelos, conceitos e fatos.

\end{itemize}

Honey e Mumford desenvolveram duas versões de questionários de aprendizagem~\cite{honey2000} para a determinação das preferências de aprendizagem do indivíduo.

\subsection{Diagnóstico do Estilos de Aprendizagem}
Existem diversas possibilidades de diagnosticar o estilo de aprendizagem. Por meio de questionários de estilo de aprendizagem é possível inferir explícitamente o estilo, exigindo que o indivíduo a ser analisado responda uma série de questões pertencentes à várias dimensões de aprendizagem.

O questionário utilizado neste trabalho~\cite{muhlbeier12} foi escolhido por se basear em vários outros instrumentos de investigação propostos por Butler, Felder e Silvermann, Honey e Mumford e Kolb (1984). O questionário analisa o aluno através de dezessete dimensões: Acomodador, Analítico, Assimilador, Ativo, Convergente, Divergente, Global, Intuitivo, Pessoal, Pragmático, Realista, Reflexivo, Sensorial, Sequencial, Teórico, Verbal, Visual. Cada dimensão possui três perguntas, totalizando o número de cinquenta e uma questões objetivas.

As respostas possuem quatro alternativas: Discordo Totalmente, Discordo, Concordo e Concordo Totalmente, onde cada questão possui uma pontuação que corresponde respectivamente a 1, 2, 3 ou 4.

O estilo de aprendizagem é determinado por meio do somatório das respostas de cada dimensão de aprendizagem. A dimensão com maior pontuação é a predominante, apresentando-se então como o estilo de aprendizagem do aluno. 

As questões das dimensões de aprendizagem foram distribuídas entre as perguntas no questionário, apresentadas na Tabela~\ref{questionario_ie}. Foram inseridas três questões correspondentes à cada dimensão integrante dos modelos propostos em~\cite{muhlbeier12}.

\begin{table}
	\caption{Distribuição de Perguntas no Questionário de Estilo de Aprendizagem. Adaptado de~\cite{muhlbeier12}}
	\centering
	\begin{tabular}{|p{4cm} | p{8cm} |}
		\hline
		\textbf{Questões}	& \textbf{Dimensão do Estilo de Aprendizagem}	\\
		\hline
		1,2,3	&  Estilo Sensorial	\\
		\hline
		4,5,6	&  Estilo Intuitivo	\\
		\hline
		7,8,9	&  Estilo Visual	\\
		\hline
		10,11,12	&  Estilo Verbal	\\
		\hline
		13,14,15	&  Estilo Sequêncial	\\
		\hline
		16,17,18	&  Estilo Global	\\
		\hline
		19,20,21	&  Estilo Divergente	\\
		\hline
		22,23,24	&  Estilo Assimilador	\\
		\hline
		25,26,27	&  Estilo Convergente	\\
		\hline
		28,29,30	&  Estilo Acomodador	\\
		\hline
		31,32,33	&  Estilo Ativo	\\
		\hline
		34,35,36	&  Estilo Reflexivo	\\
		\hline
		37,38,39	&  Estilo Teórico	\\
		\hline
		40,41,42	&  Estilo Pragmático	\\
		\hline
		43,44,45	&  Estilo Realista	\\
		\hline
		46,47,48	&  Estilo Análitico	\\
		\hline
		49,50,51	&  Estilo Pessoal	\\
		\hline
	\end{tabular}
	\label{questionario_ie}
\end{table}

Esta seção expôs os principais modelos de estudante presentes na literatura da IE, assim como o questionário de estilo de aprendizagem como uma ferramenta capaz de determinação do estilo de aprendizagem do estudante deste trabalho. É necessário agora o entendimento de técnicas computacionais para a implementação deste questionário. A seção seguinte apresentará a teoria a respeito de SMA, que será a base para o desenvolvimento deste trabalho, definido os aspectos da infraestrutura do ambiente de ensino-aprendizagem proposto.

\section{Sistemas Multiagente}\label{section:sma}

Esta seção visa expor os fundamentos acerca de SMA. Primeiramente serão apresentados as definições iniciais a respeito da Inteligência Artificial (IA) e a teoria relacionada a agentes. Em seguida o trabalho disserta a respeito das arquiteturas relacionadas aos agentes. Só então são apresentados os conceitos de SMA: Interação dos agentes, os aspectos da comunicação neste ambiente e por fim a teoria sobre ontologias.

\subsection{Conceitos}

Em~\cite{novig95} é possível identificar que a definição de IA foi separada em quatro grupos. A distinção foi feita com base na classificação das definições conforme o seu entendimento de raciocínio, comportamento, performance humana e racionalidade. A racionalidade é entendida como um conceito ideal de inteligência inerente à um sistema. Os quatro grupos que definem IA são:

\begin{itemize}
	\item Sistemas que pensam como humanos: Define IA em termos de raciocínio baseado no modelo cognitivo humano. A evidência de programas que podem operar como humanos é feita por meio da comparação da entrada, saída e o tempo de execução do programa com padrões humanos.
	\item Sistemas que pensam racionalmente: Esta definição está relacionada à lógica e procurava desenvolver programas que poderiam resolver qualquer problema descrito em uma linguagem formal com notações lógicas.
	\item Sistemas que agem como humanos: Os sistemas desta definição são classificados por meio do teste de~\emph{Turing}. O teste basicamente consiste de um entrevistador humano que, após algumas perguntas escritas ao programa, deve identificar se as respostas são ou não de um humano.
	\item Sistemas que agem racionalmente: Baseada na noção de agente racional, um agente é uma entidade que age e possui controle autônomo, percebe o ambiente, adapta a mudanças e é capaz de comprir outras metas.
\end{itemize}

O crescimento dos estudos relacionados a IA permitiu a ramificação em diversas áreas de atuação, possibilitando a resolução de diversos desafios relacionados à aplicações modernas. Uma das áreas de atuação é o auxílio na execução de aplicações que resolvem problemas de alta complexidade. 

A complexidade de várias aplicações exige muito de~\emph{hardwares} mais modestos e o seu tempo de execução é inviável, necessitando-se um maior investimento e consequentemente encarecendo o seu valor. Dessa forma outras abordagems fazem-se necessárias, como a distribução da aplicação em vários computadores que dividem a sua execução. Este é o campo de estudo da IA Moderna segundo a abordagem de Russel e Norvig~\cite{novig95} que, corroborando com a última definição de IA, propõe: Sistemas que são compostos por vários agentes coletivos atuando de forma a distribuir o seu trabalho outros. Cada agente pode possuir uma capacidade diferente, sendo possível realizar a tarefa de modo paralelo. 

Os agentes são entidades (reais ou virtuais) que funcionam de forma autônoma em um ambiente~\cite{novig95}, ou seja, não necessitam de intervenção humana para realizar processamento. Esse ambiente de funcionamento do agente geralmente contém vários outros agentes e é possível a comunicação entre eles através do ambiente por meio de troca de mensagens.

A Figura~\ref{fig:agente-basico} representa o funcionamento básico de agentes, existindo em um ambiente e atuando de forma a percebê-lo por meio de sensores, analisando os dados da interação inicial e agindo novamente sobre o ambiente de forma a modificá-lo pelos seus efetuadores.

\begin{figure}
	\centering
	\includegraphics[scale=0.75]{images/agente-basico.png}
	\caption{Representação do funcionamento básico do agente em um ambiente.}
	\label{fig:agente-basico}
\end{figure}

Alguns agentes seguem o princípio básico de racionalidade: Sempre objetivam suas ações pela escolha da melhor ação possível segundo seus conhecimentos. Logo é possível inferir que a ação de um agente nem sempre alcança o máximo desempenho, parâmetro definido para medir o grau de sucesso da ação de um agente com base nos seus objetivos. São estes os chamados Agentes Racionais.

Como dito anteriormente, agentes estão presentes em um ambiente e não possuem controle total sobre o mesmo, sendo possível no máximo a influência com a sua atuação ou a criação de outros agentes. Podemos separar ambientes em classes: Software, Físico e Relidade virtual (simulação de ambientes reais em~\emph{software}). Em~\cite{wooldridge04} são definidos os ambientes com propriedades inerentes à seu funcionamento:

\begin{itemize}
	\item Observável: Neste tipo de ambiente, os sensores dos agentes conseguem ter percepção completa do ambiente. Por exemplo, um sensor de movimento consegue ter visão total em um ambiente aberto.
	\item Determinística: O próximo estado do ambiente é sempre conhecido dados o estado atual do ambiente e as ações dos agentes. O oposto do ambiente determinístico é o estocástico, quando não há certeza do seu estado. Por exemplo, agentes dependentes de eventos climáticos.
	\item Episódico: A experiência do agente é dividida em episódios, onde cada episódio é a percepção do agente e a sua ação.
	\item Sequêncial: A ação tomada pelo agente pode afetar o estado do ambiente e ocasionar na mudança de estado
	\item Estático: O ambiente não é alterado enquanto um agente escolhe uma ação.
	\item Discreto: Existe um número definido de ações e percepções do agente para o ambiente em cada turno.
	\item Contínuo: As percepções e ações de um agente modificam-se em um espectro contínuo de valores. Por exemplo, temperatura de um sensor muda de forma contínua.
\end{itemize}

\begin{table}
	\caption{Listagem de SMA com propriedades de medida de performance, ambiente, atuadores e sensores}
	\begin{tabular}{|p{3cm} | p{3cm} | p{2cm}| p{3cm} | p{3cm} |}
		\hline
		\textbf{Tipo de agente}	& \textbf{Medida de performance} & \textbf{Ambiente} & \textbf{Atuadores}  & \textbf{Sensores}	\\
		\hline
		Sensores de estacionamento	& Avarias no veículo & Carro e garagens & Freio do carro, controle de velocidade & Sensor de proximidade	\\
		\hline
		Jogos com oponente computador	& Quantidade de vitórias &	Software & Realizar jogada & Percepção do tabuleiro	\\
		\hline
		Agentes hospitalares		& Saúde do paciente & Paciente, ambiente médico & Diagnósticos & Entrada de sintomas do paciente	\\
		\hline
	\end{tabular}
	\label{lista_agentes}
\end{table}
 
A Tabela~\ref{lista_agentes} mostra alguns exemplos de agentes, apresentando as suas características em termos de possibilidade de medida de performance, possíveis ambientes, atuadores e sensores. A primeira linha da Tabela~\ref{lista_agentes} apresenta um exemplo de agente atuando em um veículo como um sensor de estacionamento. Responsável por auxiliar o motorista no ato de estacionar o carro, o seu ambiente é da classe físico (considerando o carro e o ambiente onde está o carro). Seu sensor de proximidade é a percepção do ambiente e, caso detecte que está próximo de um obstáculo, pode atuar nos freios dos carros diminuindo a velocidade e evitando colisões. Avarias no carro podem indicar um mal funcionamento do sensor.

A segunda linha da Tabela~\ref{lista_agentes} apresenta um agente atuando em um jogo avulso. Esse ambiente é dito dinâmico, pois a cada jogada de um oponente (real ou não), o agente deve analisar a jogada feita, calcular sua próxima jogada e executá-la. O objetivo principal do agente é a vitória. O ambiente que o agente atua é um software e o seu atuador é um algum mecanismo que permite que ele realize a jogada. O sensor é o mecanismo no qual o agente irá perceber a jogada realizada pelo oponente.

Por fim, a última linha da Tabela~\ref{lista_agentes} expõe um exemplo de um agente médico atuando em um ambiente estático: Um paciente. Esse ambiente é classificado como estático por não ser alterado pelo agente nesse exemplo, porém é possível classificá-lo diferente em outras situações. O objetivo principal é monitorar a saúde do paciente, logo a medida de performance será a aproximação ou não do diagnóstico médico. Seu atuador não será diretamente no ambiente (corpo humano), será na forma de relatórios médicos e seus sensores podem variar de acordo com a doença a ser monitorada.

Segundo~\cite{wooldridge04} é possível separar as principais noções dos agentes em dois grupos. O primeiro, chamado de noção fraca, compreende as características de reatividade, proatividade e habilidade social. O conceito de reatividade está ligado com a percepção do ambiente e a reação no mesmo. Proatividade é a característica do agente tomar iniciativa e agir sem a necessidade de nenhum estímulo. Habilidade social é a capacidade de interação com outros agentes. Já a noção forte de agente envolve os seguintes aspectos:

\begin{itemize}
	\item Mobilidade: Possibilidade de movimentação pelo ambiente, por exemplo, transferência em uma rede.
	\item Veracidade: O agente não transmite informações falsas.
	\item Benevolência: Capacidade de ajudar os outros agentes.
	\item Racionalidade: A ação do agente não impedirá a realização dos seus objetivos.
	\item Cooperação: Cooperação com o usuário.
\end{itemize}

\subsection{Arquiteturas de agentes}

A arquitetura de agentes varia de acordo com a complexidade da sua autonomia, ou seja, com a capacidade de reagir aos estímulos do ambiente. Conforme verificado em~\cite{novig95}, os tipos de arquitetura são: orientadas à tabela, reflexiva simples, reflexiva baseado em modelo, baseada em objetivo, baseada em utilidade.

A primeira arquitetura a ser explorada é o agente orientado à tabelas. Todas as ações dos agentes são conhecidas e estão gravadas em uma tabela. Assim, quando o agente receber o estímulo ele já terá a ação a ser tomada previamente gravada em sua memória. Logo para construir esse tipo de agente, fica claro que além de saber todas percepções possíveis, será necessário definir ações apropriadas para todas. Isso ocasiona a criação de tabelas muito complexas e o tamanho pode facilmente passar a ordem de milhões de registros dependendo do número de entradas.

A arquitetura reflexiva simples é um dos tipos mais elementares de agente. Nele, o agente seleciona a ação com base unicamente na percepção atual, desconsiderando assim uma grande tabela de decisões. A decisão é tomada com base em regras de condição-ação: Se uma condição ocorrer, uma ação será tomada. Por exemplo, supondo um agente médico que determina o diagnóstico de uma doença no paciente caso exista alguma anomalia no organismo (Por exemplo, um paciente com febre). Uma condição-ação poderia ser:

if anomalia-organismo then diagnóstico-médico

Esse tipo de agente é bastante simples, o que é uma vantagem comparado à arquitetura de tabela. Porém, essa abordagem requer um ambiente totalmente observável, visto que esse tipo de agente possui uma inteligência bastante limitada. No exemplo do agente médico existem diversas maneiras de se detectar uma anomalia no organismo do paciente, seria necessário conhecer todas as formas para usarmos uma abordagem reativa simples.

A arquitetura baseada em modelos funciona de maneira similar a anterior. Nessa abordagem, é levado em conta a parte do ambiente que não é visível neste momento. E para saber o ``momento atual'' de um agente, é necessário guardar a informação de estado consigo. Para atualizar o estado do agente, é necessário conhecer como o mundo desenvolve-se independente do agente (no caso do exemplo, como o organismo funciona) e é necessário saber as ações dos agentes no ambiente. Esses conhecimentos acerca do ambiente são definidos como modelo de mundo. Do ponto de vista do agente, essa abordagem é considerada como baseada em modelo.

Na arquitetura baseada em objetivo, as ações do agente são executadas apenas se o aproximam de alcançar um objetivo. Para isso, será necessário algo além do estado atual do ambiente: Será necessário informações do objetivo a ser atingido. Assim o agente pode combinar as informações de estado e objetivo para determinar se deve ou não agir sobre o ambiente. Este modelo permite uma maior flexibilização das ações em determinados ambientes, visto que suas decisões são representadas de forma explícita e podem ser modificadas, com a consequência de aumento da complexidade desta abordagem. É interessante notar que esse tipo de arquitetura não trata ações com objetivos conflitantes.

Por fim, a arquitetura baseada em utilidade não utiliza apenas objetivos para realizar a próxima decisão, mas dá ao agente a capacidade de fazer comparações sobre o estado do ambiente e as ações a serem tomadas: Quais delas são mais baratas, confiáveis, resilientes e rápidas do que as outras. A capacidade de avaliação do agente é chamada de função de utilidade, que mapeia uma sequência de estados em um número real que determina o grau de utilidade. Esse mecanismo possibilita a decisão racional de escolha entre vários objetivos conflitantes. Por exemplo, escolher entre um objetivo mais barato ao invés de escolher entre o mais rápido.

\subsection{Interação entre Agentes}

Os agentes interagem entre si em um ambiente SMA, que são sistemas onde estes agentes são capazes de se comunicar, possuindo uma linguagem de alto nível para isso. Um agente possui um objetivo que, normalmente, é distinto dos objetivos de outros agentes. Além disso, ele pode ou não cooperar com outros para a realização de uma tarefa.

Em~\cite{sarmento11}, podemos encontrar as seguintes características principais em ambientes multiagente:
\begin{itemize}
	\item Fornecem protocolos específicos para comunicação e interação. Cada ambiente tem as suas particularidades: Alguns são em uma única máquina, outros são compartilhados com o mundo real e outros são distribuídos. Cabe a cada ambiente definir um protocolo onde todos agentes devem obedecer para comunicar-se.
	\item São tipicamente abertos.
	\item Contém agentes que são autônomos e individualistas.
\end{itemize}

É trivial imaginar que um SMA é designado para a solução de problemas de forma distribuída, onde o problema é fragmentado entre os agentes que, juntos, trabalham concorrentemente para a resolução deste problema, podendo ou não agir de forma cooperativa.

É importate notar a distinção de conceitos como cooperação na literatura de SMA. Em~\cite{wooldridge04}, existem duas principais diferenças do conceito entre as duas abordagens.

A primeira diferença é a designação distinta dos objetivos dos agentes. Em um ambiente com vários agentes, eles devem trabalhar estratégicamente para alcançar seus objetos. A possibilidade de agentes não cooperarem é perfeitamente plausível. A segunda diferença está na ação de forma autônoma, ou seja, tomar suas próprias decisões em tempo de execução sem interferências humanas ou de outros agentes. Logo, um ecossistema de agentes deve ser capaz de coordenar dinâmicamente suas ações, cooperando com outros agentes para atingir os objetivos. Em aplicações distribuídas, esses comportamentos já são desenhados durante o planejamento do software.

A forma de agentes resolverem problemas foi baseada na técnica distribuição cooperativa de resolução de problemas -~\emph{cooperative distributed problem solving} (CDPS). Em~\cite{durfee89}, a técnica CDPS consiste de uma rede de baixo acoplamento provida de sofisticados nós resolvedores de problemas que precisam cooperar entre si, pois nenhum deles possui recursos, informações e~\emph{expertise} suficientes para resolver algum problema sozinho. Cada nó possui uma~\emph{expertise} diferente que pode resolver parte do problema.

Inicialmente essa técnica assumiu que os problemas fossem de ordem benevolente. Isso significa que, implicitamente, os agentes compartilham o mesmo objetivo de resolver o problema proposto. Isso implica que todos eles ajudarão sempre que possível, mesmo tendo prejuízos na execução da ação, pois o objetivo geral de todos será a resolução do problema maior. Esse cenário é plausível desde que uma organização ou entidade tenha o controle de (ou possa modelar) todos os agentes.

Em um cenário mais realista (e de maior enfoque dos estudos de SMA), agentes podem pertencer à sociedades com interesses próprios, diferentes de outras sociedades. Logo, é possível ocorrer conflito de interesses neste ambiente, situação que força os agentes a cooperarem com os outros para alcançarem seus objetivos.

O processo CDPS pode ser divido em três etapas:
\begin{itemize}
	\item decomposição do problema - o problema é quebrado em instâncias menores e dividido entre os agentes. Esses subproblemas podem ser quebrados em diversas subpartes, permitindo uma maior decomposição e consequentemente um maior número de agentes trabalhando na resolução.
	\item solução do subproblema - os subproblemas são resolvidos pelos agentes. Isso pode significar troca de informações entre os agentes, por exemplo, dos que resolveram as suas instâncias compartilhando informações com outros agentes.
	\item integração da solução - as soluções dos subproblemas são integradas em uma resolução completa do problema original.
\end{itemize}

Com uma solução compartilhada de resolução de problemas, a arquitetura SMA mostra-se bastante robusta neste quesito. É necessário porém saber dos detalhes da comunicação entre os agentes, a forma de envio das mensagens, as suas linguagens, bem como outras particularidades.

\subsection{Comunicação}

A comunicação é um dos aspectos mais importantes no desenvolvimento de SMA. Problemas de sincronização entre as partes que se comunicam devem ser devidamente estudados. A situação mais simples possível da comunicação, onde o agente A envia uma mensagem ao agente B que está prontamente disponível para receber a mensagem nem sempre é a o cenário mais recorrente. Para tanto, é necessário entender os pormenores da comunicação desta abordagem.

Em uma aplicação normal (\emph{desktop} ou~\emph{web}), a comunicação entre objetos pode ser mais simplificada. Por exemplo, supondo uma aplicação em que existe dois objetos,~\emph{a} e~\emph{b} e que o objeto~\emph{a} tenha um método público chamado~\emph{m1}. O objeto~\emph{b} pode ser comunicar com o objeto~\emph{a} por meio do método~\emph{m1}, provavelmente da seguinte forma~\emph{a.m1(args)}, onde~\emph{args} são os argumentos enviados ao objeto~\emph{a} e a sintaxe pode ser diferente da apresentada, dependendo da linguagem de programação. É importante notar que o controle da execução do método~\emph{m1} não está no objeto~\emph{a}, mas sim no objeto~\emph{b}, que decide o momento o qual o método será invocado.

Esse cenário de comunicação é diferente em um ambiente SMA. Supondo dois agentes~\emph{a} e~\emph{b}, onde o agente~\emph{a} tem a capacidade de executar a ação $\alpha$. O agente~\emph{b} não poderá invocar diretamente o método que corresponde à ação $\alpha$, visto que os agentes são autônomos e independentes: Cada um tem somente tem total controle sobre suas ações e seus estados. O agente precisará enviar a solicitação da execução da ação $\alpha$ por meio de mensagem. Isso porém não garante que o agente~\emph{a} executará esta ação, pois pode não ser do seu interesse. Os agentes podem também influênciar o comportamento de outros agentes, alterando seu estado interno para a execução de ações e cooperando para o cumprimento do objetivo de outros agentes.

A comunicação dos agentes é baseada na teoria dos atos de fala (\emph{Speech act theory}) e trata a comunicação como uma ação. A teoria dos atos de fala, publicada em 1962 por John Austin~\cite{austin62}, propõe que certas expressões de linguagem natural, ou atos de fala, possuem a característica implícita de suscintar uma ação em um interlocutor, causando assim uma mudança de estado da mesma forma que uma ação física. Essas expressões descrevem as ações por meio de desejos, habilidades e crenças.

Em~\cite{verschueren09} é definido que a teoria dos atos de fala apresenta duas características:
\begin{itemize}
	\item A distinção entre o significado proferido por uma expressão e a forma como essa expressão é utilizada.
	\item Expressões de todos os tipos podem ser consideradas como atos de fala, pois têm capacidade de mudar o mundo de alguma forma.
\end{itemize}

Posteriormente o trabalho de John Searle~\cite{searle69}, relacionado ao de Austin, separa uma ação de um ato entre orador (\emph{speaker}) e ouvinte(\emph{hearer}) identifincando propriedades e condições que um discurso deve possuir para realizar ações sucedidas. Além disso, ele classifica alguns atos de discursos em 5 classes:
\begin{itemize}
	\item Representativas - Ato de um orador representar uma verdade para o ouvinte. Pode ser entendido como uma ação de informar (\emph{inform}).
	\item Diretivas - Tentativa do orador de fazer algum ouvinte realizar alguma ação por meio do seu ato. Pode ser entendido como uma ação de requisição (\emph{request}).
	\item Comissivas - O orador toma alguma atitude em relação à uma ação em andamento.
	\item Expressivas - Expressa algum estado psicológico.
	\item Declarações - Causa algum efeito relacionado a determinado assunto.
\end{itemize}

A comunicação então baseia-se nos atos de fala para prever a interação com seres humanos e é definida por meio de semânticas definidas pela teoria da IA~\cite{wooldridge04}. O formalismo para a comunicação foi escolhido de forma que foi possível representar os atos de discursos em uma lógica multimodal, que contém os operadores de desejos, habilidades e crenças dos atos de discurso.

Da mesma forma que a teoria dos atos de fala influênciou na arquitetura da comunicação, ela influênciou também as várias linguagens de comunicação dos agentes. Linguagens foram desenvolvidas para, não apenas representar ações de agentes, mas também para representar o conhecimento entre sistemas autônomos. No início dos anos 90, duas linguagens foram desenvolvidas pelo consórcio~\emph{Knowledge Sharing Effort}, encabeçados pela agência norte americana~\emph{Defense Advanced Research Projects Agency}(DARPA)~\cite{kse}.
\begin{itemize}
	\item \emph{Knowledge Query and Manipulation Language} (KQML) - Protocolo designado para a comunicação de agentes, em uma arquitetura que esses agentes sejam projetados para resolver problemas da arquitetura cliente-servidor~\cite{preece1997}. Não existe o foco com o conteúdo da mensagem.
	\item \emph{Knowledge Interchange Format} (KIF) - Criada para facilitar a troca de conhecimento entre agentes, suas declarações são providas de significados que podem ser compreensíveis a qualquer agente que conheça a estrutura da linguagem. Não possui foco na transmissão da mensagem~\cite{kifmanual}.
\end{itemize}

\subsubsection{KQML}

A linguagem KQML define um protocolo para comunicação de agentes, onde cada mensagem tem um enunciado performativo (~\emph{performative}), que varia com o seu objetivo, e em seguida os parâmetros da mensagem. O KQML define vários enunciados performativos que distinguem-se pelo objetivo da mensagem, sendo dividas em três categorias: Discursivas, intervenção e facilitação e~\emph{networking}. Por exemplo, uma mensagem com o tipo performativo~\emph{ask-one} indica que o agente remetente A deseja saber uma resposta do agente B sobre o conteúdo da mensagem. Em~\cite{preece1997}, é possível verificar que a última versão da linguagem define mais de trinta enunciados performativos.

Os maioria dos parâmetros são opcionais, sendo os mais importantes:~\emph{content} e~\emph{receiver}. A Tabela~\ref{parametros_kqml} lista os principais parâmetros em uma mensagem nesta linguagem, bem como seu significado.

\begin{table}
	\caption{Listagem de atributos de uma mensagem em KQML}
	\begin{tabular}{|p{3cm} | p{12cm} |}
		\hline
		\textbf{Parâmetro}	& \textbf{Significado}	\\
		\hline
		\emph{sender}		& Remetente da mensagem. \\
		\hline
		\emph{receiver}	& Destinatário da mensagem. \\
		\hline
		\emph{reply-with}	& Identifica se o remetente espera uma respota. Em caso positivo, o campo~\emph{in-reply-to} deve ser preenchido com a referência para a resposta. \\
		\hline
		\emph{in-reply-to}	& Campo conténdo a referência para a resposta solicitada. \\
		\hline
		\emph{language}	& Linguagem em que o campo~\emph{content} está escrito. \\ 
		\hline
		\emph{ontology}	& Indica a forma que deve ser interpretada o conteúdo do campo~\emph{content}. \\
		\hline
		\emph{content}		& Conteúdo da mensagem. \\
		\hline
	\end{tabular}
	\label{parametros_kqml}
\end{table}
O formato da mensagem é completamente compreensível aos humanos. Na mensagem apresentada na Listagem~\ref{code:exemplo-kqml} é possível identificar na primeira linha o enunciado performativo~\emph{ask-one}, onde será uma mensagem de consulta. Nas linhas abaixo, visualizamos todos os parâmetros da mensagem antecedidos por (:). O primeiro parâmetro da mensagem é~\emph{receiver} como controle-estoque, ou seja, esse será o destinatário da mensagem. O segundo parâmetro~\emph{language} tem o valor PROLOG indicando que a sintaxe do conteúdo está escrita em PROLOG. O próximo parâmetro,~\emph{ontology} informa a ontologia que expressa o conteúdo. Por fim, o parâmetro~\emph{content} indica o conteúdo da mensagem, no caso, uma consulta escrita em PROLOG perguntando o preço de um computador.

\begin{lstlisting}[label=code:exemplo-kqml,caption=Exemplo de mensagem em KQML]
(ask-one
	:receiver controle-estoque
	:language PROLOG
	:ontology PRODUTOS
	:content  (PRECO COMPUTADOR ?price)
)
\end{lstlisting}

A Listagem~\ref{code:dialogo-kqml} apresenta um exemplo de diálogo escrito em KQML onde é possível identificar a interação entre dois agentes. A primeira mensagem do diálogo possui o enunciado performativo~\emph{evaluate}, significando que o emissor A deseja avaliar o conteúdo com B. Nos parâmetros é possível notar que a linguagem da mensagem é PROLOG, utiliza a ontologia PRODUTOS e o conteúdo é uma consulta em prolog. O parâmetro~\emph{reply-with} cria uma referência para a consulta do conteúdo.

Na segunda mensagem, o seu enunciado performativo é~\emph{reply}, significando uma mensagem do tipo resposta. O parâmetro~\emph{in-reply-to q1} especifica essa mensagem como resposta à q1, ou seja, à consulta da mensagem anterior. Dessa forma a linguagem consegue distinguir respostas de um mesmo remetente. Os outros parâmetros são o emissor B, destinatário A, linguagem PROLOG e o conteúdo da mensagem, o valor da consulta q1.

\begin{lstlisting}[label=code:dialogo-kqml,caption=Exemplo de diálogo em KQML]
(evaluate
	:sender A
	:receiver B
	:language PROLOG
	:ontology PRODUTOS
	:reply-with q1
	:content  (PRECO COMPUTADOR ?price)
)
(reply
	:sender B
	:receiver A
	:language PROLOG
	:ontology PRODUTOS
	:in-reply-to q1
	:content  (=2000.00)
)
\end{lstlisting}

De acordo com~\cite{wooldridge04}, a adoção desta linguagem pela comunidade de SMA foi significante, mas sofreu diversas críticas e ocasionando o desenvolvimento de novas linguagens:
\begin{itemize}
	\item A fluídez e a não restrição do KQML fez com que diversas implementações extendidas surgissem, impossibilitando a interoperabilidade entre sistemas;
	\item Mecanismos de transporte do KQML nunca foram bem definidos, causando problemas de diversas implementações destes mecanismos e prejudicando novamente a interoperabilidade;
	\item A semântica do KQML nunca foi formalmente definida, ocasionando em má interpretações dos enunciados performativos;
	\item A linguagem não possui enunciados performativos adequados para algumas semânticas. Por exemplo, a inexistência do enunciado~\emph{comissives}.
\end{itemize}

\subsubsection{KIF}
A linguagem foi desenvolvida para expressar conhecimento a cerca de um determinado domínio, sendo possível assim a troca de conhecimentos entre agentes. De acordo com~\cite{kifmanual} a linguagem possui as seguintes características:
\begin{itemize}
	\item Semântica declarativa, sendo possível entender o seu significado sem a necessidade de um interpretador para manipulação das expressões;
	\item Logicamente compreensível;
	\item Capacidade de reproduzir meta-conhecimento, ou seja, conhecimento a respeito da representação do conhecimento. Com isso, é possível exibir novas representações de conhecimento sem a necessidade de modificar a linguagem.
\end{itemize}

A linguagem é baseada na lógica de primeira ordem onde são definidos operadores como existe($\exists$) e para todo($\forall$), possibilitando aos agentes a expressão de diversas propriedades e domínios. Além disso, ela define um vocabulário básico para a expressão de tipos básicos (números, caracteres, strings) e algumas funções padrões para lidar com esses tipos de dados (menor que, maior que, soma, dentre outros). 

O exemplo de código da Listagem~\ref{code:exemplo-kif} ilustra um exemplo de expressão na linguagem KIF, validando que a temperatura de m1 é 83 graus Célsius.

\begin{lstlisting}[label=code:exemplo-kif,caption=Exemplo de expressão de conteúdo com a linguagem KIF. Fonte:~\cite{wooldridge04}]
(= (temperature ml ) ( scalar 83 Celsius))
\end{lstlisting}

\subsection{Linguagem de Comunicação de Agentes FIPA}

Após as críticas à linguagem KQML, o consórcio~\emph{Foundation for Intelligent Physical Agents} (FIPA) começou a trabalhar em 1995 no desenvolvimento da padronização de SMA. O núcleo dessa padronização foi o desenvolvimento de uma linguagem de comunicação de agentes (ACL) comum à todas as plataformas.

Baseado na linguagem KQML, a estrutura das mensagens é a mesma e os seus atributos são semelhantes. A maior diferença entre as duas linguagens são os enunciados performativos. Foram definidos 20 tipos de mensagens performativas, muito semelhante ao KQML, porém com definições formais das interpretações dessas mensagens e não definindo nenhuma linguagem para o conteúdo da mensagem.

Devido ao fato da linguagem KQML não possuir enunciados performativos adequados, a ACL da FIPA recebeu total atenção na definição formal da semântica da linguagem. A Tabela~\ref{table:fipa-cal-spec} contém um breve resumo dos enunciados performativos disponíveis em~\cite{fipa-cal-spec}. É importante ressaltar que a especificação disponível em~\cite{fipa-cal-spec} possui toda a descrição formal de cada enunciado performativo aqui descrito.

\begin{table}
	\caption{Listagem de Enunciados Performativos}
	\begin{tabular}{|p{3cm} | p{12cm} |}
		\hline
		\textbf{Tipo}	& \textbf{Descrição}	\\
		\hline
		\emph{Accept Proposal} & Declaração de aceite de proposta feita por um agente.	\\
		\hline
		\emph{Agree} & Performativa feita por um agente indicando que aceitou o~\emph{request} feito por outro agente.	\\
		\hline
		\emph{Cancel} &	Cancela uma mensagem de~\emph{request}, informando que não irá mais participar daquela conversação.  \\
		\hline
		\emph{Call for Proposal} & Performativo que indica o início de uma negociação entre agentes.	\\
		\hline
		\emph{Confirm} & A confirmação permite ao emissor da mensagem confirmar a veracidade do conteúdo da mensagem.	\\
		\hline
		\emph{Disconfirm} & Similar à confirmação, porém informando ao emissor da não certeza do conteúdo da mensagem.	\\
		\hline
		\emph{Failure} & Permite ao agente indicar que a tentativa de executar uma ação falhou.	\\
		\hline
		\emph{Inform} & Informa à um destinatário que o conteúdo da mensagem é verdadeiro, implicando que o remetente da mensagem também acredita no seu conteúdo. É uma das mais importantes performativas feitas pela FIPA.	\\
		\hline
		\emph{Inform If} & Envia uma mensagem a qual o seu conteúdo pode ser verdadeiro ou falso.	\\
		\hline
		\emph{Inform Ref} & Similar ao \emph{Inform If}, com a diferença que ao invés de questionar se é verdadeiro ou falso, ele solicita o valor de uma expressão para o remetente.	\\
		\hline
		\emph{Not Understood} & Informa à um agente que não entendeu por que determinada ação deve ser realizada. Usada quando o estado interno do agente não é compatível com a mensagem.	\\
		\hline
		\emph{Propagate} & Consiste em propagar o conteúdo da mensagem para um grupo de agentes.	\\
		\hline
		\emph{Propose} & Permite um agente realizar uma proposta em uma negociação para outro agente.	\\
		\hline
		\emph{Proxy} & Permite ao destinatário da mensagem agir como um~\emph{proxy} para os agentes que estão descritos no conteúdo da mensagem.	\\
		\hline
		\emph{Query If} & Permite à um agente consultar um destinatário sobre a validade do conteúdo.	\\
		\hline
		\emph{Query Ref} & Similar ao \emph{query-if}, porém o agente remetente irá consultar o valor de uma expressão	\\
		\hline
		\emph{Refuse} & Indica que um determinado agente não irá executar uma ação que foi determinada por outro agente.	\\
		\hline
		\emph{Reject Proposal} & Permite um agente rejeitar uma proposta feita por outro agente em uma negociação.	\\
		\hline
		\emph{Request} & Permite à um agente requisitar que outro agente execute determinada ação.	\\
		\hline
		\emph{Request When} & Permite à um agente requisitar que outro agente execute determinada ação quando a proposição (no conteúdo da mensagem) for verdadeira.	\\
		\hline
		\emph{Request Whenever} & Similar ao \emph{request-when}, porém o agente nunca irá executar a ação quando a proposição (no conteúdo da mensagem) for verdadeira.	\\
		\hline
		\emph{Subscribe} & O conteúdo será uma proposição e o remetente da mensagem será notificado sempre que essa proposição for verdadeira.	\\
		\hline
	\end{tabular}
	\label{table:fipa-cal-spec}
\end{table}

As performativas~\emph{request} e~\emph{inform} são consideradas principais pela especificação da FIPA, pois orientam toda a linguagem de comunicação. Além disso, é possível derivar as outras performativas por meio destas.

\subsection{Ontologias}

Ontologia é um um ramo da Filosofia que dedica-se a estudar e representar a natureza do ser, existência ou realidade. De acordo com~\cite{kim2006towards} é um modelo que consiste na representação de um vocabulário com definições precisas dos termos, axiomas formais que restringem uma interpretação e expressões bem formadas de uso dos termos. Segundo~\cite{novig95}, a representação de conceitos e objetos pode ser entendida como Engenharia Ontológica:

\begin{quote}
\emph{...concentrating on general concepts-such as Actions, Time, Physical Objects, and Beliefs - that occur in many different domains. Representing these abstract concepts is sometimes called ontological engineering.}
\end{quote}

A possibilidade de representação de conhecimento por meio de ontologias é vasta. A sua forma de especificação pode ser entendida como uma hierarquia, onde os conhecimentos são organizados na forma de árvore, possibilitando a inserção de novos nós de conhecimento a qualquer momento na estrutura.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/arvore-ontologia.png}
	\caption{Ontologias superiores do mundo, cada uma indicando um conceito ou especialização do seu superior.}
	\label{fig:arvore-ontologia}
\end{figure}

A Figura~\ref{fig:arvore-ontologia} representa a organização geral de conceitos, chamado de ontologias superiores. As ontologias gerais estão representadas no topo da árvore, e as suas especialidades vão crescendo no sentido das folhas.

Em um ambiente SMA além de especificar uma linguagem para comunicação, dois agentes podem comunicar-se com relação à um determinado domínio de aplicação: Podem negociar valores de carteiras em uma organização financeira, podem trocar mensagens sobre os dados analisados de performance de veículos, enfim, dois agentes podem comunicar-se usando a mesma ontologia.

Existem muitas linguagens que foram desenvolvidas para expressar ontologias. A mais comum delas é a~\emph{eXtensible Markup Language} (XML), uma linguagem de marcação que organiza os dados de forma hierarquizada.

A Listagem~\ref{code:exemplo-xml} descreve uma ontologia de domínio de países escrita na linguagem XML. Nela observa-se a ontologia superior, País. Cada país é composto por um conjunto de estados, conténdo as propriedades nome e sigla. Cada estado possui um conjunto de cidades. Cada cidade possui os atributos nome e população. Esses atributos poderiam ser escritos de forma diferente no exemplo da Listagem~\ref{code:exemplo-xml}, porém sem alteração de semântica.


\begin{lstlisting}[language=xml,label=code:exemplo-xml,caption=Representação uma ontologia simples de cidades.]
	<Pais nome="Brasil">
		<Estado nome="Goias" sigla="GO">
			<Cidade>
				<Nome>Goiania</Nome>
				<Populacao>1.300.000</Populacao>
			</Cidade>
			<Cidade>
				<Nome>Anapolis</Nome>
				<Populacao>342.347</Populacao>
			</Cidade>
			<Cidade>
				<Nome>Aparecida de Goiania</Nome>
				<Populacao>474.219</Populacao>
			</Cidade>
		</Estado>
		<Estado nome="Sao Paulo" sigla="SP" >
			<Cidade>
				...
			</Cidade>
			...
		</Estado>
		...
	<Pais>
\end{lstlisting}

\section{Metodologias de Sistemas Multiagente}\label{section:mase}

Atualmente muitas abordagens de projeto de desenvolvimento de software conseguem com sucesso definir uma metodologia para construção, implantação e manutenção do software. A definição dessas engenharias de software possuem diversos casos de sucesso, em sua maioria nas áreas de Análise de Projetos Orientados à Objetos.

Pela característica autônoma dos agentes, não é possível compará-los à simples objetos que serão invocados por outros objetos. Não existe interação direta, apenas coordenação de ações via conversação para cada agente atingir suas próprias metas. Portanto, o advento da abordagem SMA trouxe à tona a necessidade de outras metodologias de desenvolvimento diferente daquelas, devido à diferença de abordagem do software.

Foram definidas algumas metodologias para modelagem e desenvolvimento de SMA. A metodologia~\emph{Gaia}~\cite{wooldridge2000} consiste em uma abordagem não iterativa que define análise e~\emph{design} de sistemas baseados em agentes. Esta metodologia é considerada genérica e compreensível pois pode ser aplicada a um nível muito amplo de SMA, lidando tanto com escopos mais gerais (sociedade), quanto com escopos mais específicos (agentes). Ela define as regras e tarefas em termos de uma organização, que é sinônimo de sociedade de agentes ou um SMA.

A metodologia~\emph{PASSI} (\emph{Process for Agent Societies Specification and Implementation}) é designada para o acompanhamento do desenvolvimento do sistema desde o levantamento dos requisitos até a codificação~\cite{burrafato02}. Seus modelos de projetos são baseados nas especificações da FIPA, garantindo assim a compatibilidade com o SMA a ser desenvolvido. O~\emph{PASSI} define uma metodologia cinco modelos de trabalho: Requisito do Sistema, sociedade de Agentes, implementação dos agentes, modelo de código e modelo de implantação.

A metodologia~\emph{Multiagent Systems Engineering} (MASE) é definida por meio dos requisitos e metas iniciais do SMA. Estes são levantados de forma iterativa e a partir de então são modeladas em diversas etapas as tarefas para cumprir os objetivos. O MASE utiliza-se de alguns modelos gráficos para a descrição dos agentes, seus objetivos, suas interações e a sua arquitetura. Em~\cite{scott01}, a metodologia do MASE é baseada nas mais tradicionais metodologias de desenvolvimento de software, dividida em duas fases principais: Análise e Design.

Neste trabalho, foi escolhido a metodologia de desenvolvimento MASE. Em contraste com as outras abordagens, a metodologia~\emph{GAIA} não permite a adição de novos requisitos no momento de~\emph{design}. Supondo uma situação onde estuda-se detalhadamente o~\emph{design} do sistema, ocasionalmente podem surgir alguns requisitos ou tarefas adicionais derivados desta análise. Por não permitir a adição destes requisitos, o~\emph{GAIA} mostra-se uma abordagem mais rígida e pode ser desvantajosa se comparado com outras e, portanto, foi descartada.

A necessidade do acompanhamento até o código do desenvolvimento dos agentes feito pela metodologia~\emph{PASSI} poderia exigir um conhecimento mais aprofundado do framework de desenvolvimento do SMA, necessitando assim da escolha e estudo prévio deste~\emph{framework}. Este trabalho optou então pelo não acoplamento entre o projeto de modelagem e o código e, portanto, determinou o~\emph{MASE} para o seu desenvolvimento.

Justificada a escolha da metodologia, a primeira fase do MASE, chamada de análise, consiste no levantamento e entendimento dos requisitos com o objetivo de levantar um conjunto de regras, as quais são associadas à tarefas que devem ser realizadas para o sistema atingir seus objetivos. Ao fim dessa fase, são gerados alguns artefatos que embasarão a próxima etapa da metodologia. A fase de análise pode ser dividida nos seguintes passos:

\begin{itemize}
	\item Capturar Metas;
	\item Desenvolver Casos de Uso;
	\item Refinar Regras.
\end{itemize}

A fase de design consiste na modelagem do SMA de acordo com as regras levantadas na fase anterior. O objetivo é a definição das conversações que existirão entre os agentes, bem como a arquitetura geral do sistema. Essa fase pode ser divida em quatro passos:

\begin{itemize}
	\item Criar as Classes dos Agentes;
	\item Construir Conversações;
	\item Montagem dos Agentes;
	\item Design do Sistema.
\end{itemize}

\subsection{Análise}

De acordo com~\cite{scott01}, a fase de análise objetiva o desenvolvimento de um conjunto de regras, que descrevem uma funcionalidade para uma entidade em termos de tarefas necessárias para o sistema atingir seus objetivos.

\subsubsection{Captura de Metas}

O primeiro passo dessa fase, Captura de Metas, consiste na transformação da especificação inicial do sistema em um conjunto estruturado de metas. Entende-se que as~\emph{metas} que o sistema leva em consideração são relacionadas ao sistema (e não ao usuário), visto que são mais estáveis e as metas do sistema devem satisfazer, de forma geral, os objetivos do usuário~\cite{scott01}.

Dividida em dois subpassos, o primeiro deles é a identificação de todas as metas. A partir da documentação inicial do sistema, com os requisitos  funcionais, são extraídos os objetivos de cada cenários. É importante ressaltar que as metas devem descrever de forma geral e suscinta o comportamento do sistema, descrevendo o que o comportamento deve fazer, que é distinto de ``como deve ser feito''.

As metas são divididas em quatro tipos e podem ser classificadas em mais de um: Sumário, particionada, combinada e não funcional. A meta sumário é derivada de outras metas semelhantes para que se generalize em uma meta pai. Meta particionada é a meta que, quando todas suas submetas são atingidas,  a meta passa a ser atingida. Metas combinadas são metas que são agrupadas devido à semelhaça de seus objetivos. As metas não funcionais estão relacionadas ao cumprimento objetivos que são requisitos não funcionais do sistema.

O segundo subpasso consiste na estruturação de metas em forma hierarquizada. É necessário separar quais metas são mais abstratas e de que forma elas podem ser agrupadas em forma de hierarquia. Com isso, eliminam-se algumas metas que são repetidas e identificam-se quais metas são atingidas por meio de outras submetas.

\subsubsection{Desenvolver Casos de Uso}

Neste passo o objetivo é entender o comportamento e o fluxo de execução do sistema por meio dos casos de uso, além de haver um entendimento maior sobre como o sistema comunicar-se-á. Para tanto, este passo visa o levantamento e criação dos casos de uso do sistema, bem como o diagrama de sequência para detalhar a ordem dos eventos de cada cenário.

Os casos de uso geralmente são levantados a partir dos requisitos iniciais do sistema. Nele, são identificados os participantes (atores) e a sua interação com o sistema, esclarecendo a comunicação de alguns módulos do sistema.

O diagrama de sequência define os eventos que cada interação pode criar, mostrando a ordem de execução destes eventos e a sua comunicação. Para cada caso de uso é criado no mínimo um diagrama de sequência. O objetivo principal é o levantamento dos eventos e das regras.

\subsubsection{Refinar Regras}

O último passo da fase de análise, o refinamento de regas consiste na associação metas e seus diagramas de sequências às regras e suas respectivas tarefas. A associação de tarefas à regras é a melhor forma de modelagem de SMA~\cite{scott01}. 

Em geral, a associação de metas às regras é de um para um. Durante esta etapa, algumas considerações relativas ao desenho do sistema devem ser levadas em consideração. Caso exista alguma alteração (adição de uma nova meta, alteração de caso de uso, dentre outras), a metodologia permite que o analista retorne aos passos anteriores e remodele a solução. Algumas metas podem ser combinadas em apenas uma regra, simplificando o desenho do sistema.

A interface com sistemas externos geralmente é tratada como uma regra diferente, visto que sua complexidade pode variar. O MASE não modela explicitamente um ator humano, pois o considera como um ator externo ao sistema.

Após a associação das regras, elas são estruturadas em uma modelagem chamada~\emph{MASE Role Model}, que possui informações de interações entre as tarefas. A Figura~\ref{fig:exemplo-mase-role-model} representa a notação do~\emph{MASE Role Model} utilizada por~\cite{scott01}, onde os são utilizados retângulos para expressar as regras, elipses para identificar as tarefas e as setas entre as tarefas representam as suas comunicações. Essas comunicações podem ser por meio de mensagens, caso as regras estejam separadas em agentes diferentes.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/exemplo-mase-role-model.png}
	\caption{Representação utilizada no MASE Role Model.}
	\label{fig:exemplo-mase-role-model}
\end{figure}

Caso as regras compartilhem tarefas será necessário remodelar a composição da regra, visto que o MASE não permite a duplicação de tarefas. 

De forma geral, cada regra possui uma série de tarefas que podem (ou não) executar paralelamente. Cada tarefa possui um comportamento que pode depender de outras regras para o cumprimento de seu objetivo. Preocupando-se com as conversações entre tarefas, o MASE define neste passo a criação do~\emph{Concurrent Task Diagram}. Ilustrado na Figura~\ref{fig:examplo-diagrama-tarefas-concorrentes}, é representado por meio de autômatos de estados finitos devido a facilidade de construção e entendimento. A transição consiste de uma mudança de estado do agente, podendo envolver um processamento ou uma comunicação externa.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/examplo-diagrama-tarefas-concorrentes.png}
	\caption{Representação utilizada no~\emph{Concurrent Task Diagram}.}
	\label{fig:examplo-diagrama-tarefas-concorrentes}
\end{figure}

A mudança de estado do automato é equivalente à mudança de estado do agente. A sintaxe da transição pode ser expressa por meio da notação da Listagem~\ref{code:sintaxe-concurrent-task} que define o gatilho a ser disparado, condições para a execução e as mensagens transmitidas.

\begin{lstlisting}[label=code:sintaxe-concurrent-task,caption=Sintaxe da mudança de estado.]
	trigger [guard] ^ transmission(s)
\end{lstlisting}

O~\emph{token} trigger representa um evento que inicia a mudança de estado, geralmente vindo de outra tarefa da mesma regra. O~\emph{token [guard]} é a verificação da validade desta condição e a mudança de estado só é efetivada após a validade desta condição. Por fim ocorrem as transmissões~\emph{transmission}, que podem conter o parâmetro~\emph{s}.

Para comunicações externas, dois eventos especiais foram definidos: O evento~\emph{send} indicando o envio de mensagem e o evento~\emph{receive}, indicando o recebimento de mensagem.

A mensagem sempre possui um cabeçalho performativo (definida pela FIPA, representa o objetivo da mensagem) com a seguinte sintaxe:\emph{performative(p1...pn)}, onde~\emph{p1...pn} indicam os parâmetros da mensagem.

Após a definição dos~\emph{Concurrent Tasks Diagrams}, o analista pode combinar tarefas, a fim de diminuir a complexidade do sistema. Com isso, o sistema já possui a complexidade das regras determinadas, bem como as tarefas necessárias para atingir seus objetivos.

\subsection{Design}

A fase de design é divida em quatro passos: Criar Classes dos Agentes, Construir Conversações, Montagem dos Agentes e Design do Sistema. O principal objetivo desta fase é projetar os agentes e suas interações de acordo com os insumos construídos na fase anterior.

\subsubsection{Criando as Classes dos Agentes}

Neste passo, os agentes são criados com base nas regras definidas na fase anterior. Para cada agente criado deve existir pelo menos uma regra associada, caso contrário o levantamento de regras mostra-se incompleto. Dessa forma, o MASE garante que todas os objetivos  do sistema são atingidos, já que as regras do sistema estão relacionados com as metas que foram levantadas na etapa anterior.

Ao fim deste passo é necessária a criação de um novo diagrama, o~\emph{Agent Class Diagram} representado na Figura~\ref{fig:exemplo-agent-class-diagram}. Nele, as classes dos agentes são associadas com as regras levantadas e as comunicações entre as classes.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/exemplo-agent-class-diagram.png}
	\caption{Representação utilizada no~\emph{Agent Class Diagram}.}
	\label{fig:exemplo-agent-class-diagram}
\end{figure}

\subsubsection{Construir Conversações}

A próxima etapa da segunda fase diz respeito às conversações que existirão no SMA. Cada detalhe da conversação entre dois agentes deverá ser planejada para que haja a correta comunicação entre os agentes e a quantidade de erros seja minimizada.

Quando o agente recebe uma mensagem, ele automaticamente compara com as suas conversações ativas~\cite{scott01}. Caso exista alguma conversação semelhante, o agente muda o seu estado e realiza as ações necessárias para atingir esse estado. Caso contrário, é assumido que o agente emissor deseja iniciar uma nova conversação e o receptor compara com as suas possibidades de tipos de conversação disponíveis para participar.

Neste passo, é criado o Diagrama de Comunicação. Nele, as conversações são montadas por meio do mesmo autômato de estados finitos, utilizado na fase análise, passo~\emph{refinar regras}. As transições de estado são as conversações que são feitas pelo agente.

A Listagem~\ref{code:sintaxe-conversation} apresenta a sintaxe utilizada na conversação de agentes. A sintaxe indica que a expressão é definida por meio das mensagens recebidas, condições, ações e mensagens transmitidas. O~\emph{token rec-mess} indica que a mensagem com os parâmetros~\emph{args1} foi recebida caso a condição~\emph{cond} seja verdadeira. Então o método~\emph{action} é chamado e a mensagem~\emph{trans-mess} com os argumentos~\emph{args2}. Todos os elementos da mensagem são opcionais.

\begin{lstlisting}[label=code:sintaxe-conversation,caption=Sintaxe da conversação entre dois agentes.]
	rec-mess(args1) [cond] / action ^ trans-mess(args2)
\end{lstlisting}

O diagrama de comunicação apresentado na Figura~\ref{fig:exemplo-conversation} é definido para os dois lados da conversação: Iniciador e Receptor. considerando o lado iniciador da conversação.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/exemplo-conversation.png}
	\caption{Exemplo de conversação utilizada no Diagrama de Comunicação do lado do iniciador da conversação.}
	\label{fig:exemplo-conversation}
\end{figure}

\subsubsection{Montagem dos Agentes}

Neste passo, o estado interno dos agentes é criado. É necessário nesta etapa definir a arquitetura dos agentes e a sua composição. Para tanto, é necessário criar o Diagrama de Arquitetura de Agentes, onde são representados os componentes arquiteturais dos agentes.

Os componentes internos dos agentes podem ser atributos dos agentes, ou métodos auxiliares. Um agente pode ter vários componentes internos e estes componentes obviamente se comunicarão.

No diagrama de arquitetura de agentes apresentado na Figura~\ref{fig:exemplo-diagrama-arquitetura-agentes}, a linha tracejada significa interação com sistemas externos, enquanto a outra significa interação com outros agentes do sistema.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/exemplo-diagrama-arquitetura-agentes.png}
	\caption{Notação utilizada na arquitetura de agentes.}
	\label{fig:exemplo-diagrama-arquitetura-agentes}
\end{figure}

As setas tracejadas indicam dependência com módulos externos ao agente, enquanto as outras representam dependência entre componentes.

\subsubsection{Design do Sistema}

A fase final da metodologia MASE consiste na criação de um diagrama de~\emph{deploy} dos agentes. Este diagrama consiste na representação do número de agentes que serão criados por cada máquina da aplicação, bem como suas localizações no sistema.

A Figura~\ref{fig:exemplo-diagrama-deploy} apresenta o diagrama de~\emph{deploy}, expressando os ambientes criados e seus agentes internos. O retângulo com linhas pontilhadas representam os ambientes que podem existir na aplicação. Os outros retângulos representam os agentes e as linhas que os ligam representam as suas interações.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/exemplo-diagrama-deploy.png}
	\caption{Notação utilizada no diagrama de deploy.}
	\label{fig:exemplo-diagrama-deploy}
\end{figure}

\subsubsection{Ferramenta~\emph{AgentTool}}

O~\emph{AgentTool} é uma ferramenta que dá suporte à metodologia MASE para a modelagem de um SMA. A versão 1.8.1 dá suporte à todas fases e passos do MASE~\cite{agentTool2012}, provendo suporte para a criação de diagramas, detalhamento de conversações e casos de uso simplificados.

\begin{figure}
	\centering
	\includegraphics[scale=0.4]{images/interface-agent-tool.png}
	\caption{Interface da ferramenta~\emph{AgentTool}.}
	\label{fig:interface-agent-tool}
\end{figure}

A Figura~\ref{fig:interface-agent-tool} apresenta a tela principal onde é possível visualizar as principais abas disponíveis. Ela mostra a tela para desenvolvimento do diagrama de metas hierarquizado. O avanço ou regresso do desenvolvimento é percebido durante o preenchimento das abas, que é feito de forma sequêncial da esquerda para a direita, acompanhando todos os passos da metodologia.

Conforme o avanço da modelagem do SMA, algumas abas serão habilitadas de acordo com a seleção dos objetos nos diagramas. Por exemplo, cada comunicação de tarefas no diagrama de regras deve possuir um detalhamento. Dessa forma, a aba~\emph{Task Panel} torna-se automaticamente visível ao usuário quando há esse tipo de interação.

\section{Estudos de Ferramentas e Tecnologias Relacionadas}\label{section:ferramentas}

Nesta seção estão reunidos as tecnologias que auxiliares ao desenvolvimento do SMA. A primeira seção explica alguns diagramas que são definidos na~\emph{Unified Modeling Language} (UML), necessários para entender os passos do MASE.
 
Em seguida é explicado os conceitos relacionados ao~\emph{middleware} JADE, bem como a sua arquitetura, o funcionamento dos agentes e os agentes que possuem interface gráfica.

Por fim, esta seção disserta a respeito da ferramenta JBoss Seam, responsável por interligar os principais~\emph{frameworks} JAVA e facilitar o desenvolvimento de aplicações~\emph{web} dinâmicas.

\subsection{UML}

A Linguagem Unificada de Modelagem, UML é uma linguagem visual que foi desenvolvida para a representação do software por meio de imagens objetivando o entendimento dos artefatos de forma rápida e clara, resultando em uma semântica para o projeto em questão. Segundo~\cite{fowler04} o UML faz parte de uma família de notações gráficas que ajudam na descrição e concepção de sistemas de software, principalmente em sistemas concebidos utilizando o paradigma da orientação à objetos (OO).

O UML é um padrão não proprietário, controlado pelo consórcio~\emph{Object Management Group}~\cite{omg20}. Seu nascimento é datado em 1997~\cite{fowler04}, surgindo a partir da união de diversas linguagens e ferramentas de surgiram na década de 80 e 90.
A linguagem ajuda o entendimento de como o software foi projetado, como ocorre a comunicação entre seus objetos, como suas classes são organizadas, quais são os atores que são envolvidos na utilização do software, dentre outras possibilidades de representação.

Segundo~\cite{fowler04} é possível separar o uso do UML de três formas distintas de modelagem conforme o objetivo de uso: Rascunho, planta de software e como linguagem de programação. 

A utilização como rascunho é facilita a comunicação entre as pessoas envolvidas no projeto, sejam desenvolvedores discutindo funcionalidades do software ou gestores explicando funcionalidades em alto nível. O objetivo neste uso é a comunicação de alguns aspectos do sistema de forma rápida, sem a necessidade de formalizar artefatos para o projeto.

A utilização do UML como planta de software são documentos detalhados que são criados para documentação do software, sendo divida em duas sub-categorias: Engenharia reversa e engenharia normal. Na engenharia reversa, os diagramas são gerados a partir de uma ferramenta que faz a leitura do código fonte e gera os diagramas desejados, que são utilizados para auxiliar o leitor no entendimento do sistema. Na engenharia normal, a idéia é modelar o sistema detalhadamente antes de qualquer desenvolvimento, prevendo quais serão os módulos do sistema, bem como a sua a comunicação.

No uso como linguagem de programação, o UML é utilizado para geração de código executável por ferramentas avançadas de modelagem. Esse modo requer a modelagem de estado e comportamento do sistema, para fins de detalhar todo o comportamento e lógica do sistema em código.

\subsubsection{Diagramas UML}

O UML descreve 13 tipos de diagramas, conforme a Figura~\ref{fig:categorias-diagramas}, os quais podem ser categorizados como estruturais e comportamentais. Apesar da grande quantidade diagramas envolvidos no UML, de acordo com~\cite{larman08}, a maioria dos processos de desenvolvimento de software utilizam-se de poucos modelos devido à maior significância de alguns. A metodologia de desenvolvimento de SMA utiliza-se apenas dos seguintes diagramas:

\begin{itemize}
	\item Diagrama de Caso de uso;
	\item Diagrama de Sequência.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[scale=0.75]{images/categorias-diagramas.png}
	\caption{Categorização dos Diagramas UML 2.0~\cite{fowler04}.}
	\label{fig:categorias-diagramas}
\end{figure}

\paragraph{Diagrama de Caso de Uso}

Casos de uso são relatos textuais que são utilizados para descobrir e descrever os requisitos do sistema. Consiste da descrição de como um ator utiliza uma funcionalidade do sistema para atingir algum objetivo relacionado. Em~\cite{larman08}, os casos de uso devem ser prioritariamente desenvolvidos de forma textual e o seu respectivo diagrama deve ser desenvolvido de forma secundária, somente para ilustrar o relato textual.

Um dos objetivos do caso de uso é a facilidade do levantamento dos requisitos, tanto para os analistas de um sistema, quanto para os clientes envolvidos. A definição de uma modelagem em comum facilita o entendimento das partes interessadas, tornando o caso de uso uma boa maneira de simplificar o entendimento do comportamento do sistema~\cite{larman08}, bem como envolver todos as partes interessadas(~\emph{stakeholders}) na sua construção. Em~\cite{cockburn01}, o caso de uso é um contrato de como será o comportamento do sistema. Este contrato será feito por meio dos atores que existirão, da sua interação com o sistema, bem como os cenários existentes.

Duas definições fazem-se necessárias para o entendimento do caso de uso. A primeira delas é o ``Ator'' do caso de uso. Ele é um objeto com um comportamento definido no sistema. É possível definir o ator como uma pessoa, organização ou mesmo o próprio sistema (quando utiliza serviços do próprio sistema), desde que tenham sempre um papel relacionado. Existem três tipos de atores relacionados ao sistema:
\begin{itemize}
	\item Ator Principal: Seus objetivos são satisfeitos por meio da utilização do sistema.
	\item Ator de Suporte: Fornece algum serviço para o sistema.
	\item Ator de Bastidor: Expressa algum interesse pelo comportamento do caso de uso.
\end{itemize}

A segunda definição envolvida é a de cenário. Um cenário é uma sequência de interações entre os atores e o sistema. Os cenários são separados por ações de interesses de atores. Logo o caso de uso pode ser considerado como um conjunto de cenários de interações de atores com o sistema.

Dessa forma, o caso de uso deve deixar claro os requisitos funcionais do sistema, bem como o seu comportamento. Existem três formas de se escrever um caso de uso, diferindo em seu nível de formalidade e formatos: Resumido, informal e completo. Este trabalho usará o nível de caso de uso completo, devido ao nível de detalhe de sua estruturação. Os casos de uso são estruturados de diversas formas. De acordo com~\cite{larman08}, o padrão de estruturação mais adotado foi desenvolvido por Alistar Cockburn~\cite{cockburn01}, descrito na Tabela~\ref{tabela:topicos_uc}.

\begin{table}
	\caption{Estruturação Detalhada de Caso de Uso}
	\begin{tabular}{|p{5cm} | p{9cm}|}
		\hline
		\textbf{Seção do Caso de Uso}	& \textbf{Significado} \\
		\hline
		Nome do Caso de Uso 	& Nome do caso de uso, iniciando-se com um verbo.  \\
		\hline
		Escopo	& Escopo descrito pelo caso de uso. \\
		\hline
		Nível	& Podem ser níveis de objetivo de usuário (quando descrevem os cenários para atingir o objetivo do usuário) ou nível de subfunção (subpassos para dar suporte a um objetivo de usuário). \\
		\hline
		Ator Principal	& O ator que procura os serviços para atingir seus objetivos.  \\
		\hline
		Interessados e Interesses	& Significado.  \\
		\hline
		Pré-Condições	& Condições que antecedem o caso de uso e são necessárias para atingir os objetivos. \\
		\hline
		Garantia de Sucesso	& Objetos que podem ser analisados após a execução do caso de uso a fim de validar a correta execução do sistema.  \\
		\hline
		Cenário de Sucesso Principal	& Chamado também de fluxo básico, este cenário descreve o fluxo principal do sistema que satisfaz os interesses dos~\emph{stakeholders}.  \\
		\hline
		Extensões	& Chamado também de fluxos alternativos, são fluxos auxiliares ou cenários de erros que são relacionados ao cenário de sucesso principal. \\
		\hline
		Requisitos Especiais	& Registram requisitos não funcionais do sistema e que estão relacionados com o caso de uso. \\
		\hline
		Lista de Variantes Tecnologias de Dados	& Listagem de dificuldades técnicas, desafios técnicos que valem a pena registrar no caso de uso. \\
		\hline
		Frequência de ocorrência	& Frequência de ocorrência deste caso de uso. \\
		\hline
	\end{tabular}
	\label{tabela:topicos_uc}
\end{table}

A diagramação do caso de uso por UML é uma forma de representação do sistema, mostrando fronteiras do sistema, comunicação e comportamento entre os atores. A Figura~\ref{fig:diagrama-uml} representa a sugestão de diagramação visual do caso de uso, propondo forma de representação de atores, casos de uso e atores auxiliares.

\begin{figure}
	\centering
	\includegraphics[scale=0.75]{images/exemplo-uml.png}
	\caption{Sugestões de notação de caso de uso proposto por~\cite{larman08}}
	\label{fig:diagrama-uml}
\end{figure}

\paragraph{Diagrama de Sequência}

O Diagrama de Sequência é um documento criado para ilustrar os eventos descritos em um caso de uso de forma sequencial e temporal, mostrando a interação de atores externos ao sistema e os eventos que eles geram durante essa interação. O UML possui uma notação específica para este diagrama, onde todos os elementos são representados.

Neste diagrama, são representados para cada cenário do caso de uso os eventos que os atores geram, bem como a ordem da sua interação. No diagrama os atores são representados na parte superior (com a mesma notação do diagrama de caso de uso). Abaixo dos atores é apresentada a linha de tempo, crescendo de cima para baixo. 

Durante a interação do ator com o sistema, eventos de sistema são gerados e iniciam toda a execução do cenário do caso de uso, ou operação do sistema. A execução dos eventos ocorre até o último evento cronológico na linha do tempo. Os eventos gerados pela interação entre os atores ocorrem na linha do tempo de forma cronológica e ordenada com a mesma ordem dos eventos do cenário do caso de uso.

A nomenclatura dos eventos deve sempre iniciar com um verbo, podendo ser seguida de um substantivo. Além disso, deve-se sempre expressar a nomenclatura em níveis genéricos verbais, nunca detalhando a funcionalidade do sistema.

A Figura~\ref{fig:exemplo-diagrama-sequencia} ilustra a notação de diagramas de sequência, onde é possível identificar a interação entre um ator e uma entidade do sistema. É fácil notar que os eventos estão ocorrendo de forma ordenada de cima para baixo.
\begin{figure}
	\centering
	\includegraphics[scale=0.75]{images/exemplo-diagrama-sequencia.png}
	\caption{Notação de diagrama de sequência, exibindo a comunicação de um ator e uma entidade (sistema)}
	\label{fig:exemplo-diagrama-sequencia}
\end{figure}

O primeiro evento é iniciado pelo ator, onde o método~\emph(listarProdutos()) da Entidade é invocado. Esse método gera a resposta~\emph(produtos) para o ator. A interação seguinte acontece dentro de um retângulo, do tipo~\emph{loop} e de nome ``Verificar''. Esse retângulo permite que o diagrama de sequências represente um loop, onde todos os eventos serão repetidos enquanto a condição de guarda for verdadeira, no caso do exemplo, enquanto retorno for igual a~\emph{true}. O UML permite diversos operadores além do loop, como por exemplo a negação, a assertiva, o~\emph{break}, dentre outros.

Dentro do retângulo, o ator chama o método~\emph(realizarOperacao), enviado o parâmetro~\emph{operação}. A entidade retorna um valor, que será testado na guarda para a continuidade da conversação. Por fim, o ator chama o método~\emph{finalizarAcao} da entidade. Por não haver outra interação em seguida, o cenário é considerado como encerrado. 

A importância do desenho de um diagrama de sequência está no fato de detalhar os eventos do sistema que são gerados pela interação de atores externos, pois assim é possível ter uma análise comportamental do sistema com base nesses eventos. Neste nível de análise, é possível estudar o comportamento do sistema no nível de projetar o que ele faz, porém sem necessariamente explicar como o faz~\cite{larman08}.

O diagrama de sequência geralmente está relacionado com o caso de uso, primeiramente pelo fato de descrever um cenário de caso de uso, mas também pelo fato de o caso de uso conter todos os detalhes do cenário. O diagrama de sequência apenas deixará claro a interação entre os atores e os eventos derivados dessa interação.

\subsection{Ferramentas de SMA}

Os~\emph{frameworks} projetados para o desenvolvimento de SMA visam simplificar o desenvolvimento de aplicações ao implementar uma infra-estrutura básica que provê recursos ao programador. O seu objetivo é garantir os recursos que são essenciais em um SMA, possibilitando o foco do programador no desenvolvimento da aplicação. Diversas ferramentas foram criados para a criação de SMA, cada um com características distintas.

O~\emph{AgentMom}~\cite{agentMom} é um~\emph{framework} de comunicação que foi criado na linguagem JAVA para o desenvolvimento de agentes, conversações e a passagem de mensagens simples nestas conversações. Possui a capacidade de criação de grupos específicos para envio de mensagens (\emph{multicast}) e encriptação do conteúdo da mensagem.

O~\emph{MaDKit}~\cite{madkit} é uma ferramenta para desenvolvimento SMA também desenvolvido em JAVA, onde é possível definir uma plataforma pelo modelo organizacional, agrupando agentes e determinando regras para este grupo.

O~\emph{Java Agent Development Framework} (JADE) é um~\emph{middleware} criado para facilitar o desenvolvimento de SMA. Desenvolvido inicialmente pela Telecom Italia e desde 2000 é um projeto open source. Seu desenvolvimento de baixo acoplamento permite que seja possível integrar várias bibliotecas auxiliares (~\emph{addons}) para facilitar o desenvolvimento de aplicações.

Segundo~\cite{bellifemine07}, ele foi desenvolvido seguindo todas as especificações da FIPA, o que garante uma intercomunicação com outras plataformas. O JADE foi desenvolvido na linguagem JAVA, possibilitando o uso de diversas bibliotecas e frameworks desenvolvidos na linguagem.
O middleware provê várias funcionalidades básicas que abstraem e simplificam o desenvolvimento de aplicações, com o objetivo do desenvolvedor estar mais preocupado com o comportamento do agente do que com a infra estrutura da plataforma.

Este trabalho optou pela escolha da ferramenta JADE, pois no contraste com as outras ferramentas, foi possível destacar alguns aspectos. O~\emph{framework MaDKit} não permite o desenvolvimento de agentes com comportamento e interação complexos. Tanto o~\emph{framework AgentMon} quanto o~\emph{MaDKit} não possuem a conformidade das suas mensagens com linguagem ACL, especificado pela FIPA. Dessa forma, as duas ferramentas foram descartadas.

Dada a escolha da ferramenta, é necesário entender as particularidades do JADE. O sistema de mensagem no JADE funciona de forma assíncrona. Um agente não precisa estar necessariamente disponível para receber as mensagens, visto que elas são enfileiradas e processadas em ordem. Além disso, não é necessário que um agente tenha uma referência para outro agente a fim de comunicar-se.

A arquitetura de um SMA desenvolvido em JADE funciona de forma semelhante à rede P2P (\emph{Peer-to-Peer}), onde cada agente possui um nome único na plataforma - Agent ID (AID) - e é livre para entrar e sair a qualquer momento durante a execução. Uma plafatorma JADE possui normalmente os seguintes elementos:

\begin{itemize}
	\item Agent Management System (AMS) é o agente responsável por supervisionar toda a plataforma e criar um elo entre os agentes. Esse tipo de serviço é chamado de~\emph{white pages} e indexa todos os agentes da plataforma.
	\item Directory Facilitator (DF) é o agente responsável por registrar todos os serviços e prover a funcionalidade de busca para os agentes. Este tipo de serviço é chamado de~\emph{yellow pages}.
\end{itemize}

Os agentes executam em threads separadas garantindo o não compartilhamento de recursos para evitar condições de corrida. A plataforma é responsável também por manter o ciclo de vida dos agentes. Durante a criação dos agentes, eles são automaticamente registrados no serviço de~\emph{white pages}

A mobilidade de agentes entre máquinas também é feita de forma transparente pelo JADE. Em~\cite{bellifemine07}, a mobilidade do agente pode transportar o estado do agente (sob certas condições) entre processos e máquinas.

Uma das características mais importantes do~\emph{middleware} é o suporte nativo à ontologias e linguagens de comunicação FIPA. As ontologias podem ser modeladas (expressando ações, conceitos e predicados) de forma simples e clara, além de ser possível restringir as ontologias à determinados agentes que devem a conhecer.

\subsubsection{Arquitetura}

A Figura~\ref{fig:arquitetura-jade} representa o ambiente de execução JADE, ilustrando os principais elementos da arquitetura distribuídos em três máquinas (dois servidores e um~\emph{desktop}). Cada máquina possui um container e vários agentes.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/arquitetura-jade.png}
	\caption{Representação da arquitetura principal do JADE.Adaptado de~\cite{bellifemine07}.}
	\label{fig:arquitetura-jade}
\end{figure}

O container principal(\emph{main container}), presente na máquina do centro, possui algumas diferenças entre os outros, chamados de~\emph{Container-1} e~\emph{Container-2}, abringando agentes primordiais na plataforma que atendem às especificações da FIPA (número 23 e 61~\cite{bellifemineGuide02}). O container principal possui o componente~\emph{container table} (CT), que possui as referências para os objetos e os endereços de comunicação dos nós que compõe a plataforma.

Além disso, o container principal possui uma tabela global para descrição de agentes (GADT) que registra todos os agentes da plataforma e o seu endereço. Os outros containeres possuem uma cópia em cache da tabela para, caso a tabela principal seja corrompida, possa ser substituída.

O primeiro deles é o~\emph{Directory Facilitator} (DF), agente responsável por registrar todos os serviços disponíveis na plataforma. O segundo agente é o~\emph{Agent Management System} (AMS) é o agente responsável por supervisionar toda a plataforma, registrando os agentes que estão rodando, bem como o seu estado. 

\subsubsection{Implementação dos Agentes}
O JADE define a classe abstrata~\emph{Agent}, que é a base para todos os agentes definidos. O desenvolvedor tem apenas o trabalho de extender esta classe e implementar o comportamento no método~\emph{setup()}. O fato de extender a classe abstrata implica em herdar várias características já definidas pelo JADE (registro, configuração, etc.) e métodos que podem ser chamados para a implementação do comportamento do agente.

Cada agente possui um identificador único (Agent ID - AID) que identifica o agente em toda plataforma. Por padrão, o formato do AID possui primeiramente o nome do agente seguido do caracter '@', por fim o endereço da plataforma onde o agente está. Este AID é atribuído durante o registro do agente no AMS. Neste registro, é possível também registrar os serviços do agente no DF.

A implementação do método~\emph{setup()} é invocado durante o registro do agente e deve estabelecer um comportamento para ele. Este comportamento diz respeito à ação que será realizada pelo agente durante a ocorrência de um evento. O registro/cancelamento dos comportamentos é feito pelos métodos exibidos na Listagem~\ref{code:exemplo-register}.

\begin{lstlisting}[language=java,label=code:exemplo-register,caption=Exemplo de registro de comportamento nos agentes.]
	void addBehaviour( Comportamento )
	void removeBehaviour( Comportamento )
	void addSubBehaviour( Comportamento )
	void removeSubBehaviour( Comportamento )
\end{lstlisting}

Os comportamentos são separados em primitivos e compostos. A diferença entre ambos é a possibilidade dos comportamentos compostos poderem agregar vários outros comportamentos simples ou compostos, sendo eles:~\emph{ParallelBehaviour, SequentialBehaviour}. De maneira distinta, os comportamentos primitivos tem relação direta com o tempo, acontecendo durante um período de espera ou após o envio de uma mensagem. São eles:~\emph{SimpleBehaviour, CyclicBehaviour, TickerBehaviour, OneShotBehaviour, WakerBehaviour} e~\emph{ReceiverBehaviour}.

\subsubsection{Ciclo de Vida dos Agentes}
O JADE implementa o ciclo de vida especificado pela FIPA. Os possíveis estados da plataforma são:

\begin{itemize}
	\item \emph{INITIATED} - Após a criação do objeto, antes do registro do objeto no AMS, o agente assume o estado de iniciado. Este estado significa que o agente ainda não está disponível para a execução de ações na  plataforma.
	\item \emph{ACTIVE} - Neste estado o agente é registrado no AMS, possuindo assim o AID e o endereço. Ele está pronto para a execução do trabalho na plataforma.
	\item \emph{SUSPENDED} - O agente está com as atividades suspensas e está em modo ocioso.
	\item \emph{WAITING} - O agente está bloqueado esperando algum evento acontecer para executar alguma ação. Tipicamente, este estado é usado para fazer o agente esperar por alguma mensagem.
	\item \emph{DELETED} - O agente está destruído e sua thread de execução é terminada. O seu registro será removido do AMS e a sua referência removida da JVM.
	\item \emph{TRANSIT} - O agente está movendo-se de uma plataforma para uma nova localização. Mesmo em transito, é possível enviar mensagens para este agente, visto que serão empilhadas na sua fila de mensagens e posteriormente processadas quando ele assumir o estado ACTIVE.
\end{itemize}

Para cada uma das transições de estados existem métodos que são invocados em um momento anterior. Eles são úteis para a execução de ações que antecedem a mudança de estado. Por exemplo: Durante a mudança do estado ACTIVE para DELETE, o método~\emph{doDelete()} é encarregado de implementar ações que antecedam o fim do agente, como que o agente desfaça o registro dos seus serviços no DF.

\subsubsection{Interface Gráfica}
O JADE permite o desenvolvimento de agentes com suporte à interface gráfica. Dessa forma, é possível desenvolver uma interação simples do agente com o ser humano.

Por padrão, o JADE utiliza diversos agentes que utilizam-se de interfaces gráficas para a comunicação dos humanos que, dentre outras funcionalidades, permitem o envio de dados, controle do agente e testes da plataforma. Ferramentas como gerência dos~\emph{containers}, visualização do DF, criação de mensagens a partir de agentes falsos (\emph{sniffers}), dentre outros são disponibilizados nativamente para o desenvolvedor. Na Figura~\ref{fig:tela-jade} é apresentada a interface básica do agente RMA, ilustrando o ambiente de execução. É possível identificar apenas o~\emph{container} principal da aplicação. Nele, existem os três agentes principais registrados descritos anteriormente: AMS, DF e o próprio RMA.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/tela-jade.png}
	\caption{Apresentação da Interface do agente RMA.}
	\label{fig:tela-jade}
\end{figure}

\subsection{JBoss Seam}

No mundo corporativo do JAVA, muitos frameworks são responsáveis por partes específicas de uma aplicação. Seguindo as especificações propostas para a plataforma (JSR), as aplicações implementam integrações com o banco de dados (Hibernate, JPA), integração com a camada de visualização (Struts 1~\cite{struts1} e 2~\cite{struts2}, JSF~\cite{jsf2012}), contextos Java e injeção de dependência~\cite{di2012}. Porém a integração destes frameworks nem sempre é trivial, demandando muito tempo dos desenvolvedores para a correta configuração.

Neste aspecto surge o~\emph{JBoss Seam}. Ele é um~\emph{framework} que reune as principais tecnologias de desenvolvimento~\emph{web} na linguagem Java. Ele integra as tecnologias~\emph{Asynchronous JavaScript and XML} (AJAX),~\emph{JavaServer Faces} (JSF),~\emph{Java Persistence} (JPA),~\emph{Enterprise Java Beans} (EJB 3.0) e~\emph{Business Process Management} (BPM) em uma única ferramenta que objetiva o desenvolvimento ágil de aplicações e o foco do programador na lógica de negócio~\cite{seamSite}.

A pilha de aplicações do Seam, representada na Figura~\ref{fig:servidor-app-seam}, contém todos as tecnologias que são utilizados pelo~\emph{framework}. Caso o desenvolvedor deseje utilizar outras tecnologias, o Seam provê configurações para que outras ferramentas possam ser integradas facilmente à aplicação.

\begin{figure}
	\centering
	\includegraphics[scale=0.65]{images/servidor-app-seam.png}
	\caption{Representação da pilha de aplicações do Seam~\cite{allen09}.}
	\label{fig:servidor-app-seam}
\end{figure}

Em~\cite{allen09}, uma das principais ferramentas do Seam é o~\emph{seam-generator}. Com ele, é possível gerar uma estrutura básica de projeto, com arquivos de construção, bibliotecas compatíveis e as configurações necessárias para o início do desenvolvimento e o~\emph{deploy} em um servidor de aplicação.

Além disso, uma das grandes vantagens do~\emph{seam-generator} é a geração automática de código, criando a partir de uma tabela no banco de dados todas as operações necessárias para a visualização, inserção, exclusão e atualização de dados (CRUD), diminuindo assim o tempo de desenvolvimento de aplicações.

Portanto este trabalho optou por utilizar o~\emph{JBoss Seam}, pois engloba outras importantes ferramentas em uma única solução, facilitando assim o desenvolvimento da aplicação~\emph{web}. A facilidade pode ser constatada a partir dos aspectos já mencionados, como integração nativa entre as ferramentas da sua pilha de aplicações e geração automática de código.

\section{Trabalhos Correlatos}\label{section:trabcorrelatos}
É possível fazer comparações deste trabalho com diversas áreas de conhecimentos correlatos. Os trabalhos presentes nesta seção foram selecionados a partir de um levantamento que buscou soluções para melhorias na educação com o apoio de tecnologia. Estes trabalhos estão relacionados com a área de atuação deste trabalho, seja em IA, Estilos de Aprendizagem, SMA ou AVA.

Na área de auxílio de alunos, alguns trabalhos assemelham-se com o propósito deste trabalho. A implementação de um agente artificial integrado à um tutor inteligente~\cite{soaresagente} que identifica dificuldades de aprendizagem por meio de técnicas de IA. Ele prima pela agradável interação com humanos com o intuito de facilitar a compreensão da ferramenta. Sua abordagem porém não é voltada para a abordagem multidimensional de inferência do aluno, bem como a solução não prevê a inferência de dados vindos de outros AVA.

O trabalho~\cite{bativa2011}, na área de identificação de conhecimentos, visa a determinação de estilos de aprendizagem dos alunos por meio da plataforma chamada ``Ferramenta de Identificação de Perfis de Aprendizes – FIPA'', uma aplicação multicamadas que faz a identificação do perfil por meio de questionários de estilos de aprendizagem. Apesar da inferência do estilo de aprendizagem, esta plataforma utiliza uma abordagem distinta deste trabalho, sendo uma arquitetura cliente-servidor. 

Esta arquitetura não possui alguns benefícios da abordagem SMA, conforme~\cite{helbing11}: A possibilidade de representação de entidades individuais como, no domínio  deste trabalho, a modelagem do conhecimento de cada aluno por meio de agentes. Outra característica é a representação das suas interações por meio de equações, regras ou operações lógicas que podem flexibilizar a modelagem. Por fim, modelos baseados em agentes são recomendáveis para simulações devido as suposições realisticas inerentes a seu domínio.

O trabalho~\cite{geyer2001semeai} utiliza-se da abodagem SMA para a adaptação do ensino na internet. A adaptação ocorre conforme as características individuais de cada aluno e pode modificar características como a estratégia de ensino, seleção de materiais que são mais adequados ao aluno de acordo com o seu perfil. Este ambiente assemelha-se bastante com o presente trabalho, porém o seu foco não é na modelagem multidimensional do aluno.

A modelagem multidimensional tem por objetivo a separação clara das dimensões do aluno para restringir o domínio de atuação de cada agente. Dessa forma, cada a gente expressará uma quantidade menor de propriedades de cada dimensão, sendo possível obter uma informação mais precisa e expressiva de cada dimensão, conforme pode ser visto nas simulações em~\cite{helbing11}.

Por fim, o AVA EDULIVRE~\cite{rabelo2010identificacao} possibilita a inferência implícita de modelos e perfis individuais de estudantes da educação infantil. Com o perfil de cada aluno e de todos os alunos em geral, o educando poderá desenvolver nortear seu trabalho da melhor forma possível. A abordagem deste trabalho não utiliza-se de agentes, diferindo assim do foco deste trabalho. Além disso, o EDULIVRE apresenta a estratégia de ser o AVA e não permite integração com outros ambientes.

Conforme exposto alguns trabalhos na área de IE utilizam de diversas tecnologias ou abordagens para a construção de ambientes de ensino-aprendizagem. Todavia, o capítulo seguinte apresentará uma proposta que tende melhorar o modelagem do perfil de aprendizagem por meio da definição de uma arquitetura específica baseada em SMA. Essa arquitetura apresenta aspectos que tangem o modelo multidimensional do aluno propondo uma divisão de agentes para inferência do perfil e aspectos da infraestrutura do ambiente de ensino-aprendizagem.













